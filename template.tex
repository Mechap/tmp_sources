\section*{Templates}

Templates are a family of identifiers that includes:
\begin{paracol}{2}
\begin{itemize}
    \item[(i)] class templates \vspace{10pt}
    \item[(ii)] function templates \vspace{10pt}
    \item[(iii)] alias templates \vspace{10pt}
        \switchcolumn
    \item[(iv)] variable templates \vspace{10pt}
    \item[(v)] concepts
\end{itemize}
\end{paracol}

A template by itself is not a type, nor a function, nor any other actual entities. No code is generated from a source file that only contains template definitions.

%\textcolor{black}{\rule{16cm}{0.2mm}}

In order to write a template definition we need to use the \mintinline{c++}|template| specifier and introduce template parameters :

\begin{paracol}{2}
\begin{minted}{c++}
template <parameters>
...
\end{minted}

\switchcolumn

\vspace{5pt}
where \mintinline{c++}|parameters| can be types or values. 

\end{paracol}

\section*{Template Instantiations}

\begin{paracol}{2}
    
In order for any code to appear, a template must be instantiated\footnote{Template instantiation has a different meaning here than usual instantiations like class instantiations.}, i.e., the template arguments must be determined at compile time so that the compiler can generate an actual entity (function, class, variable, alias, \dots).

\vspace{10pt}

This entity is said to be a template instantiation.

\switchcolumn
\begin{minted}{c++}
    template <typename T>
    struct A { ... };

    template <typename T>
    void b() { ... }

    A<int> a;
    b<float>();
\end{minted}
\end{paracol}

\vspace{10pt}
\hrule
\vspace{10pt}


In the example above, we provide template arguments for A and b so that the compiler can generate two respective instantiations : a struct from the template struct definition A and a function from the template function definition b. Those instantiations are said to be implicit. \\

\begin{paracol}{2}
Likewise, you can also instantiate a template definition by making an explicit template instantiation, meaning that you request the compiler to generate an instantiation, i.e., an actual entity, without instantiating that entity by creating variables. 

\switchcolumn

\begin{minted}{c++}
template <typename T>
struct A { ... };

template struct A<int>;
\end{minted}
\end{paracol}

\begin{paracol}{2}
\begin{minted}{c++}
namespace N {
    template <typename T>
    struct A { ... };
};

using N::A;

template struct A<int>; // error
template struct N::A<int>; // error
\end{minted}

\switchcolumn

In the example above, the compiler generates an instantiation from the template definition A, though we did not define any variables. 

\vspace{10pt}

    Please note that explicit template instantiations have to be placed in namespace in which the template definition is defined regardless of \mintinline{c++}|using| directives\footnote{The \mintinline{c++}|using| is also used to use elements from a namespace as if they were defined in the current namespace}.
\end{paracol}

Hence we have to rely on implicit instantiations if we want to instantiate A in the global namespace.

\begin{minted}{c++}
namespace N { 
    template <typename T> 
    struct A { ... }; 
} 
using N::A; 

void(A<int>{});
\end{minted}

\section*{Template Specializations}

A template specialization allows the customizations of a primary template for a given set of instructions, meaning that the specialization provides an alternative definition that can be used instead of the original one. From a compiler perspective, specializations (at least explicit ones) and instantiations mean the same thing except that instantiations are generated by the compiler (following the primary template definition) whereas specializations are written by the developer himself who has also the ability to provide an alternative definition of the primary template.

\vspace{10pt}

In C++, there are two kinds of template specializations:
\begin{itemize}
    \item[(i)] Explicit template specializations, which introduce names.
\end{itemize}

\begin{paracol}{2}
\begin{minted}{c++}
template <typename T> 
struct is_float {  
    static constexpr bool value = false;  
}; 

template <> 
struct is_float<float> { 
    static constexpr bool value = true; 
}; 
\end{minted}

\switchcolumn

\vspace{5pt}

For instance, in the example on the left, we make an explicit specialization from the primary template struct A. If we call the template struct with float as the template type parameter, then the compiler must not generate a new instantiation and has to use the existing specialization. 

\vspace{10pt}

We can think of specializations as a way to tell the compiler to customize the primary template's definition. Thus, \mintinline{c++}|A<T>::value == true| if T is float.

\end{paracol}

\begin{itemize}
    \item[(ii)] Partial template specialisations, which introduce an alternative template definition
\end{itemize}

A partial specialization of a template provides an alternative definition of the template that is used instead of the primary template definition when the arguments match those given by a partial specialization.

\vspace{10pt}

However, unlike explicit template specializations and template instantiations, template partial specializations do not introduce new names. Instead, when the primary template name is used, any reachable partial specializations of the primary template are considered.

\begin{paracol}{2}
\begin{minted}{c++}
template <typename T> 
struct is_const { 
    static constexpr bool value = false; 
}; 

template <typename T> 
struct is_const<const T> { 
    static constexpr bool value = true; 
};
\end{minted}

\switchcolumn

In the example on the left, we defined a primary template definition with a type T and a static constant member variable named "value" which is false by default. When the primary template is used, i.e., when there's no existing template instantiations/explicit specializations, the partial specialization is considered. If T appears to be a constant type, then the compiler has to use the existing partial specialization that we have defined and instantiate it.\footnote{In this case, instantiating a specialization makes sense since partial specializations are an altnernative definition of the primary template.}


Thus, the resulting name is the instantiation generated from the partial specialization, and value is true.
\end{paracol}

\newpage
